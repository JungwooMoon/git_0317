<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>3D Ï∫êÎ¶≠ÌÑ∞ AR + Ïö©Ïñ¥ Ïù∏Ïãù</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        object-fit: cover;
        z-index: -1;
      }
      canvas {
        display: block;
      }
      button {
        position: absolute;
        z-index: 10;
        padding: 10px 16px;
        background-color: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        border-radius: 5px;
        cursor: pointer;
        font-size: 14px;
      }
      #resetButton {
        top: 10px;
        right: 10px;
      }
      #captureButton {
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
      }
      #switchCameraButton {
        bottom: 20px;
        right: 10px;
        display: none;
      }
      #speechBubble {
        position: absolute;
        bottom: 100px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(255, 255, 255, 0.9);
        border-radius: 12px;
        padding: 12px 16px;
        font-size: 16px;
        display: none;
        z-index: 15;
      }
      button:hover {
        background-color: rgba(0, 0, 0, 0.9);
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.0.2/dist/tesseract.min.js"></script>
  </head>
  <body>
    <video id="webcam" autoplay muted playsinline></video>
    <button id="resetButton">ÌöåÏ†Ñ Ï¥àÍ∏∞Ìôî</button>
    <button id="captureButton">üì∏ ÏÇ¨ÏßÑ Ï¥¨ÏòÅ</button>
    <button id="switchCameraButton">üîÑ Ïπ¥Î©îÎùº Ï†ÑÌôò</button>
    <div id="speechBubble"></div>

    <script type="module">
      import * as THREE from 'https://esm.sh/three@0.158.0';
      import { GLTFLoader } from 'https://esm.sh/three@0.158.0/examples/jsm/loaders/GLTFLoader.js';

      const video = document.getElementById('webcam');
      const switchBtn = document.getElementById('switchCameraButton');
      const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

      const glossary = {
        ÎåÄÏ∂ú: 'Ïù¥ÏûêÎ•º Ï°∞Í±¥ÏúºÎ°ú ÎèàÏùÑ ÎπåÎ†§Ï£ºÎäî ÌñâÏúÑÏïº! ÎÇ¥Í∞Ä ÎèàÏùÑ Ï£ºÎ©¥ ÎÑàÎäî Îçî ÎßéÏùÄ ÎèàÏùÑ ÎÇòÌïúÌÖå ÎèåÎ†§Ï§òÏïº ÌïòÎäîÍ±∞Ïïº?',
        Ïù¥Ïûê: 'ÎèàÏùÑ ÎπåÎ¶∞ ÎåÄÍ∞ÄÎ°ú Ï∂îÍ∞ÄÎ°ú ÎÇ¥Îäî ÎèàÏù¥ÏóêÏöî!',
        'ÎåÄÏ∂ú Î∞©Ïãù': 'Îã¥Î≥¥ ÎåÄÏ∂úÍ≥º Ïã†Ïö© ÎåÄÏ∂úÏù¥ ÏûàÏñ¥',
        'Îã¥Î≥¥ ÎåÄÏ∂ú':
          'ÎÑàÍ∞Ä ÎèàÏùÑ Î™ª Í∞öÏúºÎ©¥ ÎÑàÏùò ÏÜåÏ§ëÌïú Î¨ºÍ±¥ÏùÑ ÎÇ¥Í∞Ä Í∞ÄÏßÄÎäî Í±∞Ïïº! Ïñ¥Îñ§ Î¨ºÍ±¥ÏùÑ Ï£ºÍ≥† Ïã∂Ïñ¥? Î¨ºÎ°† Í∞öÏúºÎ©¥ Ï£ºÏßÄ ÏïäÏïÑÎèÑ Ï¢ãÏïÑ',
        'Ïã†Ïö© ÎåÄÏ∂ú':
          'ÎÑàÎ•º ÎØøÍ≥† ÎèàÏùÑ ÎπåÎ†§Ï£ºÎäî Í±∞Ïïº. ÎÑàÍ∞Ä Íæ∏Ï§ÄÌûà ÎèàÏùÑ Î≤åÍ≥† ÏûàÎã§Î©¥ Ïã†Ï≤≠ Í∞ÄÎä•Ìï† ÌôïÎ•†Ïù¥ ÎÜíÏïÑ!!',
        ÎßåÍ∏∞ÏùºÏãúÏÉÅÌôò:
          'Îß§ÎÖÑ Ïù¥ÏûêÎßå ÎÇ¥Îã§Í∞Ä, ÎßàÏßÄÎßâÏóê Ìïú Î≤àÏóê ÏõêÍ∏àÍ≥º Ïù¥ÏûêÎ•º Î™®Îëê Í∞öÎäî Î∞©ÏãùÏù¥Ïïº!',
        ÏõêÍ∏àÍ∑†Îì±ÏÉÅÌôò:
          'Ï≤òÏùåÏóê ÎßéÏù¥ ÎÇ¥Í≥† Ï†êÏ†ê Ï†ÅÍ≤å ÎÇ¥Îäî Î∞©ÏãùÏù¥Ïïº. ÎèàÏùÄ Ï†ÅÍ≤å ÎÇ¥ÏßÄÎßå Ï¥àÎ∞ò Î∂ÄÎã¥Ïù¥ ÌÅ¥Í±∏.',
        ÏõêÎ¶¨Í∏àÍ∑†Îì±ÏÉÅÌôò:
          'Îß§Îã¨ ÎπÑÏä∑Ìïú Í∏àÏï°ÏùÑ Í∞öÏïÑÏÑú Í≥ÑÏÇ∞Ïù¥ Ïâ¨Ïõå. ÌïòÏßÄÎßå Í∞öÏïÑÏïº Ìï† ÎèàÏùÄ Ï†úÏùº ÎßéÏïÑ',
        Í∏àÎ¶¨: 'ÎèàÏùÑ ÎπåÎ¶¥ Îïå, ÏñºÎßàÎÇò Îçî ÎÇ¥Ïïº ÌïòÎäîÏßÄÎ•º ÌçºÏÑºÌä∏(%)Î°ú ÎÇòÌÉÄÎÇ∏ Ïà´ÏûêÏòàÏöî. Í∏àÎ¶¨Ïóê Îî∞Îùº Í∞öÎäî ÎèàÏù¥ Î≥ÄÌï¥Ïöî.',
        'Í≥†Ï†ï Í∏àÎ¶¨': 'Ï≤òÏùå Ï†ïÌïú Í∏àÎ¶¨Í∞Ä ÎÅùÎÇ† ÎïåÍπåÏßÄ Î≥ÄÌïòÏßÄ ÏïäÏïÑ. ÎßàÏùåÏù¥ Ìé∏ÏïàÏßÄ?',
        'Î≥ÄÎèô Í∏àÎ¶¨':
          'Í∏àÎ¶¨Í∞Ä Ï£ºÍ∏∞Ï†ÅÏúºÎ°ú Î≥ÄÌï¥ ÎèÑÎ∞ïÏùÑ Ï¢ãÏïÑÌïòÍ±∞ÎÇò Í≤ΩÏ†ú ÌùêÎ¶ÑÏóê ÏûêÏã†Ïù¥ ÏûàÏúºÎ©¥ ÎèÑÏ†ÑÌïòÎùºÍµ¨!',
      };

      let currentFacing = 'environment';
      let stream = null;

      async function setupCamera(facingMode = 'user') {
        if (stream) stream.getTracks().forEach((track) => track.stop());

        try {
          stream = await navigator.mediaDevices.getUserMedia({
            video: isMobile ? { facingMode: { exact: facingMode } } : true,
            audio: false,
          });
          video.srcObject = stream;
          currentFacing = facingMode;
        } catch (err) {
          console.error('Ïπ¥Î©îÎùº Ïó∞Í≤∞ Ïã§Ìå®:', err);
        }
      }

      if (isMobile) {
        switchBtn.style.display = 'block';
        switchBtn.addEventListener('click', () => {
          const nextFacing = currentFacing === 'user' ? 'environment' : 'user';
          setupCamera(nextFacing);
        });
      }

      setupCamera(isMobile ? currentFacing : 'user');

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        70,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.z = 2;

      const renderer = new THREE.WebGLRenderer({
        alpha: true,
        preserveDrawingBuffer: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(0, 1, 2).normalize();
      scene.add(light);

      const loader = new GLTFLoader();
      let model;

      loader.load(
        'honey.glb',
        (gltf) => {
          model = gltf.scene;
          model.scale.set(0.5, 0.5, 0.5);
          scene.add(model);
        },
        undefined,
        (err) => {
          console.error('Î™®Îç∏ Î°úÎìú Ïã§Ìå®:', err);
        }
      );

      let rotating = false;
      let lastTime = 0;
      const speed = 2.5;

      function animate(time) {
        requestAnimationFrame(animate);
        const delta = (time - lastTime) / 1000;
        lastTime = time;
        if (model && rotating) model.rotation.y += delta * speed;
        renderer.render(scene, camera);
      }

      animate();

      window.addEventListener('click', () => (rotating = !rotating));
      document.getElementById('resetButton').addEventListener('click', (e) => {
        e.stopPropagation();
        if (model) model.rotation.y = 0;
      });

      document
        .getElementById('captureButton')
        .addEventListener('click', (e) => {
          e.stopPropagation();
          const width = renderer.domElement.width;
          const height = renderer.domElement.height;

          const canvas = document.createElement('canvas');
          canvas.width = width;
          canvas.height = height;
          const ctx = canvas.getContext('2d');

          ctx.drawImage(video, 0, 0, width, height);
          ctx.drawImage(renderer.domElement, 0, 0, width, height);

          const link = document.createElement('a');
          link.href = canvas.toDataURL('image/png');
          link.download = `snapshot_${new Date()
            .toISOString()
            .replace(/[:.]/g, '-')}.png`;
          link.click();

          // OCR + Îã®Ïñ¥ ÏÑ§Î™Ö Ï≤òÎ¶¨
          Tesseract.recognize(canvas, 'eng+kor', {
            logger: (m) => console.log(m),
          }).then(({ data: { text } }) => {
            console.log('Ïù∏ÏãùÎêú ÌÖçÏä§Ìä∏:', text);
            const foundWord = Object.keys(glossary).find((word) =>
              text.includes(word)
            );
            if (foundWord) {
              const bubble = document.getElementById('speechBubble');
              bubble.innerText = glossary[foundWord];
              bubble.style.display = 'block';
              setTimeout(() => {
                bubble.style.display = 'none';
              }, 5000);
            } else {
              alert('ÏÑ§Î™ÖÌï† Îã®Ïñ¥Î•º Ï∞æÏßÄ Î™ªÌñàÏñ¥Ïöî.');
            }
          });
        });

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
